package homework;

import java.util.Scanner;

public class answer_SW_7393_대규의팬덤활동 {
    static int T, N;
    static int[][][] dp;

    public static void main(String args[]) throws Exception
    {
 
        Scanner sc = new Scanner(System.in);
        // 0~9 숫자 모두 사용하도록 visit 필요
        // 어떤 경우에 대해 visit 체크를 해서 선택/비선택을 결정하는 것이 아니라
        // dp 를 완성해 가는 과정에서 활용함. dp[1] --> dp[2] --> dp[3]....
        // 

        dp = new int[101][10][1024];
        int mod = 1000000000;

        // 한 자리 (dp[1]) 경우, 1~9 까지의 수 하나씩만 가능 
        // 1<<i
        for(int j=1; j<=9; j++){
            // 1<<i; 2-4-6-8-16-32-....
            // dp[1][1][1<<1] : 0 0 0 0 0 0 0 0 1 0 : 2   -> dp[1][1][2] = 1;
            // dp[1][2][1<<2] : 0 0 0 0 0 0 0 1 0 0 : 4   -> dp[1][2][4] = 1;
            // dp[1][3][1<] : 0 0 0 0 0 0 1 0 0 0 : 8   -> dp[1][3][8] = 1;
            // dp[1][4][1<<4] : 0 0 0 0 0 1 0 0 0 0 : 16  -> dp[1][4][16] = 1;
            // ..
            // dp[1][8][1<<8] : 0 1 0 0 0 0 0 0 0 0 : 256 -> dp[1][8][256] = 1;
            // dp[1][9][1<<9] : 1 0 0 0 0 0 0 0 0 0 : 512 -> dp[1][9][512] = 1;
            dp[1][j][1<<j] = 1;
        }

        //               <-  j
        // 9 8 7 6 5 4 3 2 1 0 
        // 1 1 1 1 1 1 1 1 1 1
        // 222222222*2 = 1024 : k 가 0 ~ 1023 순회하면서
        int bit;

        // 자리수 - 숫자 - bit 구조를 자리수 - bit - 숫자 구조로 바꿔도 상관없음.
        // 자리수
        for(int i=2; i<=100; i++){
            // 숫자 0 ~ 9
            for(int j=0; j<=9; j++){

                // 자리수와 사용 숫자가 결정되면 dp[1][j][1<<j] 처럼 dp[i][j] 완성
                // i = 2
                // j = 3
                // k = 4    : 0 0 0 0 0 0 0 1 0 0
                // 1 << j   : 0 0 0 0 0 0 1 0 0 0
                // k|(1<<j) : 0 0 0 0 0 0 1 1 0 0 : 12 ( 3, 2 )
                // dp[2][3][12] = dp[1][2][4] + dp[1][4][4] = 1 + 1 = 2 (2가지 방법이 있다는 의미)
                // 두 자리 일 때, 3은                   2            와               4 를 취할 수 있다.

                // i = 2
                // j = 3
                // k = 6    : 0 0 0 0 0 0 0 1 1 0
                // 1 << j   : 0 0 0 0 0 0 1 0 0 0
                // k|(1<<j) : 0 0 0 0 0 0 1 1 1 0 : 14 ( 3, 2, 1 )
                // dp[2][3][14] = dp[1][2][6] + dp[1][4][6] = 0 + 0 = 0 (0가지 방법이 있다는 의미)
                // 두 자리 일 때, 3은                  0            와               0 를 취할 수 있다.

                // 위와 같이 반복 수행하면서 dp를 완성
                // dp[i][x][1023] 이 모든 숫자를 다 사용한 경우에 해당
                // i<10 인 경우 dp[i][x][1023] 은 0

                for(int k=1; k<1024; k++){

                bit = k|(1<<j);
                
                if( j == 0 ) {
                    dp[i][j][bit] += dp[i-1][j+1][k];
                }else if( j == 9 ) {
                    dp[i][j][bit] += dp[i-1][j-1][k];
                }else {
                    dp[i][j][bit] += dp[i-1][j-1][k] + dp[i-1][j+1][k];
                }
                
                dp[i][j][bit] %= mod;

            }
        }
    }
 
    int T=sc.nextInt();

    for(int tc = 1; tc <= T; tc++){
        int result = 0;
        N = sc.nextInt();
        for(int i=0; i<10; i++){
            result += dp[N][i][1023];
            result %= mod;
        }
        System.out.println("#"+ tc + " " + result);
 
    }
    
    sc.close();
}
}